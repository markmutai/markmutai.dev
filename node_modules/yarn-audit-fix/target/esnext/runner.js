import chalk from 'chalk';
import { join } from 'node:path';
import { getFlow } from './flows.js';
import { getSelfManifest, getTemp, normalizeFlags, readJson } from './util.js';
/**
 * Build running context.
 */
export const getContext = (flags = {}) => {
    const cwd = flags.cwd || process.cwd();
    const manifest = readJson(join(cwd, 'package.json'));
    const temp = getTemp(cwd, flags.temp);
    const ctx = {
        cwd,
        temp,
        flags,
        manifest,
        versions: {},
        bins: {},
    };
    ctx.ctx = ctx;
    return ctx;
};
/**
 * Run cmd stack.
 * @param stages
 * @param ctx
 */
export const exec = (stages, ctx) => {
    for (const step of stages.flat(5)) {
        if (typeof step === 'string') {
            !ctx.flags.silent && console.log(chalk.bold(step));
        }
        else if (typeof step === 'function') {
            step(ctx);
        }
    }
};
/**
 * Public static void main.
 */
export const runSync = (_flags = {}, _flow) => {
    if (_flags.V) {
        console.log(getSelfManifest().version);
        return;
    }
    const flags = normalizeFlags(_flags);
    const ctx = getContext(flags);
    const flow = _flow || getFlow(flags.flow);
    try {
        exec(flow.main, ctx);
    }
    catch (err) {
        ctx.err = err;
        !flags.silent && console.error((err.stderr?.toString() || err.error || err.status || err));
        exec(flow.fallback, ctx);
        throw err;
    }
};
// Legacy async implementation
export const run = (_flags = {}, _flow) => new Promise((resolve, reject) => {
    try {
        runSync(_flags, _flow);
        resolve();
    }
    catch (e) {
        reject(e);
    }
});
run.sync = runSync;
